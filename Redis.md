Redis 是速度非常快的**非关系型（NoSQL）内存键值数据库**，可以存储键和五种不同类型的值之间的映射。

键的类型只能为字符串，值支持五种数据类型：**字符串、列表、集合、散列表、有序集合**。

Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。

# 一、数据类型

| 数据类型 | 可以存储的值           |                             操作                             |
| :------- | ---------------------- | :----------------------------------------------------------: |
| STRING   | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作<br />对整数和浮点数执行自增或者自减操作 |
| LIST     | 列表                   | 从两端压入或者弹出元素<br />对单个或者多个元素进行修剪， <br />只保留一个范围内的元素 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对<br />获取所有键值对检查某个键是否存在 |
| SET      | 无序集合               | 添加、获取、移除单个元素<br />检查一个元素是否存在于集合中<br />计算交集、并集、差集 从集合里面随机获取元素 |
| ZSET     | 有序集合               | 添加、获取、删除元素<br />根据分值范围或者成员来获取元素<br />计算一个键的排名 |

## 1. STRING

二进制安全，一个键最大能存储512MB

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | SET key value <br />设置指定 key 的值                        |
| 2    | GET key <br />获取指定 key 的值。                            |
| 3    | GETRANGE key start end <br />返回 key 中字符串值的子字符     |
| 4    | GETSET key value <br />将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 |
| 5    | GETBIT key offset <br />对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 |
| 6    | MGET key1 [key2..\] <br />获取所有(一个或多个)给定 key 的值。 |
| 7    | SETBIT key offset value <br />对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 |
| 8    | SETEX key seconds value <br />将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 |
| 9    | SETNX key value <br />只有在 key 不存在时设置 key 的值。     |
| 10   | SETRANGE key offset value <br />用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 |
| 11   | STRLEN key <br />返回 key 所储存的字符串值的长度。           |
| 12   | MSET key value [key value ...\] <br />同时设置一个或多个 key-value 对。 |
| 13   | MSETNX key value [key value ...\] <br />同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 |
| 14   | PSETEX key milliseconds value <br />这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 |
| 15   | INCR key <br />将 key 中储存的数字值增一。                   |
| 16   | INCRBY key increment <br />将 key 所储存的值加上给定的增量值（increment） 。 |
| 17   | INCRBYFLOAT key increment <br />将 key 所储存的值加上给定的浮点增量值（increment） 。 |
| 18   | DECR key <br />将 key 中储存的数字值减一。                   |
| 19   | DECRBY key decrement key <br />所储存的值减去给定的减量值（decrement） 。 |
| 20   | APPEND key value <br />如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。 |

## 2. LIST

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | BLPOP key1 [key2 \] timeout <br />移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
| 2    | BRPOP key1 [key2 \] timeout <br />移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
| 3    | BRPOPLPUSH source destination timeout <br />从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
| 4    | LINDEX key index <br />通过索引获取列表中的元素              |
| 5    | LINSERT key BEFORE\|AFTER pivot value <br />在列表的元素前或者后插入元素 |
| 6    | LLEN key <br />获取列表长度                                  |
| 7    | LPOP key <br />移出并获取列表的第一个元素                    |
| 8    | [LPUSH key value1 value2\] <br />将一个或多个值插入到列表头部 |
| 9    | LPUSHX key value <br />将一个值插入到已存在的列表头部        |
| 10   | LRANGE key start stop <br />获取列表指定范围内的元素         |
| 11   | LREM key count value <br />移除列表元素                      |
| 12   | LSET key index value <br />通过索引设置列表元素的值          |
| 13   | LTRIM key start stop <br />对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 |
| 14   | RPOP key <br />移除列表的最后一个元素，返回值为移除的元素。  |
| 15   | RPOPLPUSH source destination <br />移除列表的最后一个元素，并将该元素添加到另一个列表并返回 |
| 16   | RPUSH key value1 [value2\] <br />在列表中添加一个或多个值    |
| 17   | RPUSHX key value <br />为已存在的列表添加值                  |

## 3. hash

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | HDEL key field1 [field2\] <br />删除一个或多个哈希表字段     |
| 2    | HEXISTS key field <br />查看哈希表 key 中，指定的字段是否存在。 |
| 3    | HGET key field <br />获取存储在哈希表中指定字段的值。        |
| 4    | HGETALL key <br />获取在哈希表中指定 key 的所有字段和值      |
| 5    | HINCRBY key field increment <br />为哈希表 key 中的指定字段的整数值加上增量 increment 。 |
| 6    | HINCRBYFLOAT key field increment <br />为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 |
| 7    | HKEYS key <br />获取所有哈希表中的字段                       |
| 8    | HLEN key <br />获取哈希表中字段的数量                        |
| 9    | HMGET key field1 [field2\] <br />获取所有给定字段的值        |
| 10   | HMSET key field1 value1 [field2 value2 \] <br />同时将多个 field-value (域-值)对设置到哈希表 key 中。 |
| 11   | HSET key field value <br />将哈希表 key 中的字段 field 的值设为 value 。 |
| 12   | HSETNX key field value <br />只有在字段 field 不存在时，设置哈希表字段的值。 |
| 13   | HVALS key <br />获取哈希表中所有值。                         |
| 14   | HSCAN key cursor [MATCH pattern\] [COUNT count] <br />迭代哈希表中的键值对。 |

## 4. SET

通过哈希表实现，添加、删除和查找的时间复杂度都是O(1)

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | SADD key member1 [member2\] <br />向集合添加一个或多个成员   |
| 2    | SCARD key <br />获取集合的成员数                             |
| 3    | SDIFF key1 [key2\] <br />返回给定所有集合的差集              |
| 4    | SDIFFSTORE destination key1 [key2\] <br />返回给定所有集合的差集并存储在 destination 中 |
| 5    | SINTER key1 [key2\] <br />返回给定所有集合的交集             |
| 6    | [SINTERSTORE destination key1 key2\] <br />返回给定所有集合的交集并存储在 destination 中 |
| 7    | SISMEMBER key member <br />判断 member 元素是否是集合 key 的成员 |
| 8    | SMEMBERS key <br />返回集合中的所有成员                      |
| 9    | SMOVE source destination member <br />将 member 元素从 source 集合移动到 destination 集合 |
| 10   | SPOP key <br />移除并返回集合中的一个随机元素                |
| 11   | SRANDMEMBER key [count\] <br />返回集合中一个或多个随机数    |
| 12   | SREM key member1 [member2\] <br />移除集合中一个或多个成员   |
| 13   | SUNION key1 [key2\] <br />返回所有给定集合的并集             |
| 14   | SUNIONSTORE destination key1 [key2\] <br />所有给定集合的并集存储在 destination 集合中 |
| 15   | SSCAN key cursor [MATCH pattern\] [COUNT count] <br />迭代集合中的元素 |

## 5. ZSET

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | ZADD key score1 member1 [score2 member2\] <br />向有序集合添加一个或多个成员，或者更新已存在成员的分数 |
| 2    | ZCARD key <br />获取有序集合的成员数                         |
| 3    | ZCOUNT key min max <br />计算在有序集合中指定区间分数的成员数 |
| 4    | ZINCRBY key increment member <br />有序集合中对指定成员的分数加上增量 increment |
| 5    | ZINTERSTORE destination numkeys key [key ...\] <br />计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 |
| 6    | ZLEXCOUNT key min max <br />在有序集合中计算指定字典区间内成员数量 |
| 7    | ZRANGE key start stop [WITHSCORES\] <br />通过索引区间返回有序集合指定区间内的成员 |
| 8    | ZRANGEBYLEX key min max [LIMIT offset count\] <br />通过字典区间返回有序集合的成员 |
| 9    | ZRANGEBYSCORE key min max [WITHSCORES\] [LIMIT] <br />通过分数返回有序集合指定区间内的成员 |
| 10   | ZRANK key member <br />返回有序集合中指定成员的索引          |
| 11   | ZREM key member [member ...\] <br />移除有序集合中的一个或多个成员 |
| 12   | ZREMRANGEBYLEX key min max <br />移除有序集合中给定的字典区间的所有成员 |
| 13   | ZREMRANGEBYRANK key start stop <br />移除有序集合中给定的排名区间的所有成员 |
| 14   | ZREMRANGEBYSCORE key min max <br />移除有序集合中给定的分数区间的所有成员 |
| 15   | ZREVRANGE key start stop [WITHSCORES\] <br />返回有序集中指定区间内的成员，通过索引，分数从高到低 |
| 16   | ZREVRANGEBYSCORE key max min [WITHSCORES\] <br />返回有序集中指定分数区间内的成员，分数从高到低排序 |
| 17   | ZREVRANK key member <br />返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 |
| 18   | ZSCORE key member <br />返回有序集中，成员的分数值           |
| 19   | ZUNIONSTORE destination numkeys key [key ...\] <br />计算给定的一个或多个有序集的并集，并存储在新的 key 中 |
| 20   | ZSCAN key cursor [MATCH pattern\] [COUNT count] <br />迭代有序集合中的元素（包括元素成员和元素分值） |

## 6. HyperLogLog

Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。

在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | PFADD key element [element ...\] <br />添加指定元素到 HyperLogLog 中。 |
| 2    | PFCOUNT key [key ...\] <br />返回给定 HyperLogLog 的基数估算值。 |
| 3    | PFMERGE destkey sourcekey [sourcekey ...\] <br />将多个 HyperLogLog 合并为一个 HyperLogLog |

# 二、数据结构

## 字典

dictht 是一个**散列表结构**，使用**拉链法**解决哈希冲突。

Redis 的字典 dict 中包含**两个哈希表 dictht**，这是为了方便进行 rehash 操作。在**扩容时**，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。

rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。

**渐进式 rehash** 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。

在 rehash 期间，每次对字典执行**添加**、**删除**、**查找**或者**更新**操作时，都会执行一次渐进式 rehash。

采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。

## 跳跃表

默认最大层级：**64**

是有序集合的底层实现之一。

跳跃表是基于**多指针有序链表**实现的，可以看成多个有序链表。

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。

与红黑树等平衡树相比，跳跃表具有以下优点：

- 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
- 更容易实现；
- 支持无锁操作。

# 三、过期策略

## 键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

## 过期策略

- **惰性删除**：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null
- **定期删除**：定期随机抽取20个key检查过期并删除 

## 数据淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

Redis 具体有 8 种淘汰策略：

| 策略            | 描述                                                     |
| --------------- | -------------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选**最近最少**使用的数据淘汰 |
| volatile-lfu    | 从已设置过期时间的数据集中挑选**最低频率**使用的数据淘汰 |
| volatile-random | 从已设置过期时间的数据集中**任意选择**数据淘汰           |
| volatile-ttl    | 从已设置过期时间的数据集中挑选**将要过期**的数据淘汰     |
| allkeys-lru     | 从所有数据集中挑选**最近最少**使用的数据淘汰             |
| allkeys-lfu     | 从所有数据集中挑选**最低频率**使用的数据淘汰             |
| allkeys-random  | 从所有数据集中**任意选择**数据进行淘汰                   |
| noeviction      | **禁止**驱逐数据                                         |

作为**内存数据库**，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。

# 四、持久化

Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。

1. **RDB持久化**：Redis DataBase。将某个时间点的所有数据都存放到硬盘上。

   可以将**快照**复制到其它服务器从而创建具有相同数据的服务器副本。

   如果系统发生故障，将会丢失最后一次创建快照之后的数据。

   如果数据量很大，保存快照的时间会很长。

   功能核心函数`rdbSave`(生成RDB文件)和`rdbLoad`(从文件中加载)两个函数

2. **AOF持久化**：将**写命令**添加到 AOF 文件（Append-Only File）的末尾。

   使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：

   | 选项     | 同步频率                 |
   | -------- | ------------------------ |
   | always   | 每个写命令都同步         |
   | everysec | 每秒同步一次             |
   | no       | 让操作系统来决定何时同步 |

   - always 选项会严重减低服务器的性能；
   - **everysec 选项比较合适**，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
   - no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。

   随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

# 五、事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为**流水线**，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 **MULTI** 和 **EXEC** 命令将事务操作包围起来。

# 六、事件

Redis 服务器是一个**事件驱动程序**。

1. **文件事件**：服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。

   Redis 基于 **Reactor 模式**开发了自己的网络事件处理器，使用 **I/O 多路复用**程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。

2. **时间事件**：服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。

   时间事件又分为：

   - 定时事件：是让一段程序在指定的时间之内执行一次；
   - 周期性事件：是让一段程序每隔指定时间就执行一次。

   Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。

## 事件的调度与执行

服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。

事件调度与执行由 aeProcessEvents 函数负责，将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数。

![Redis事件处理](Redis事件处理.png)

# 七、复制与分片

## 复制

通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器，并且**不支持主主复制**。

1. **连接过程**：
   1. 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
   2. 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
   3. 主服务器每执行一次写命令，就向从服务器发送相同的写命令。

2. **主从链**：随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个**中间层**来分担主服务器的复制工作。**中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。**

## 分片

分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。

假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。

- 最简单的方式是**范围分片**，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
- 还有一种方式是**哈希分片**，使用 **CRC32 哈希函数**将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。

根据执行分片的位置，可以分为三种分片方式：

- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
- 服务器分片：Redis Cluster。

# 八、架构模式

1. 单机版
2. 主从复制
3. 哨兵
4. 集群(proxy型)
5. 集群(直连)

## 1.单机版

特点：简单

问题：内存容量有限；处理能力有限；布不具有高可用

## 2.主从复制

Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。

只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。

**特点：**

- master/slave 角色
- master/slave 数据相同
- 降低 master 读压力在转交从库

**问题：**

- 无法保证高可用
- 没有解决 master 写的压力

## 3.哨兵(Sentinel)

Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：

- 监控（Monitoring）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
- 提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
- 自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。

**特点：**

- 保证高可用
- 监控各个节点
- 自动故障迁移

**缺点：**

- 主从模式，切换需要时间丢数据
- 没有解决 master 写的压力

## 4.集群(proxy型)

Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器；Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。

**特点：**

- 多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins
- 支持失败节点自动删除
- 后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致

**缺点：**

- 增加了新的 proxy，需要维护其高可用。
- failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预

## 5.集群(直连)

从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。

**访问步骤**：

1. 把16384槽按照节点数量进行平均分配，由节点进行管理 
2. 对每个key按照CRC16规则进行hash运算 
3. 把hash结果对16383进行取余 
4. 把余数发送给Redis节点 
5. 节点接收到数据，验证是否在自己管理的槽编号的范围    
   - 如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果    
   - 如果在自己管理的槽编号范围外，则向客户端返回moved重定向异常

**特点：**

- 无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。
- 数据按照 slot (0到16383，共16384个槽)存储分布在多个节点，节点间数据共享，可动态调整数据分布。
- 可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。
- 高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本
- 实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。

**缺点：**

- 资源隔离性较差，容易出现相互影响的情况。
- 数据通过异步复制,不保证数据的强一致性

# 九、分布式锁

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。

**如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？**

set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！

# 十、安全问题

- 缓存穿透：大量查询空值
- 缓存雪崩：缓存大量失效
- 缓存击穿：大量请求同时产生

## 1. 缓存穿透

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

**如何避免？**

- 缓存空值，设置较短的过期时间，低于5分钟。
- 布隆过滤器：Bloom Filter。对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。

## 2. 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。

**避免方案**

- 先对缓存key加锁，再查询数据库，之后回写缓存，释放锁
- 数据预热：缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。可以通过缓存reload机制，预先去更新缓存，在即将发生大并发访问前手动触发加载缓存不同的key
- 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
- 定时更新缓存
- 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

## 3. 缓存击穿

在平常高并发的系统中，大量的请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。

**解决方案**

先对缓存key加锁，再查询数据库，之后回写缓存，释放锁

# 十一、Memcached的区别

1. Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
2. Redis支持数据的备份，即master-slave模式的数据备份。
3. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
4. Redis可以实现主从复制，实现故障恢复。
5. Redis的Sharding技术： 很容易将数据分布到多个Redis实例中

# 十二、应用场景

1. **计数器**：可以对 String 进行自增自减运算，从而实现计数器功能。

   Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

2. **缓存**：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

3. **查找表**：查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

4. **消息队列**：List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。

5. **会话缓存**：可以使用 Redis 来统一存储多台应用服务器的会话信息。

   当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

6. **分布式锁实现**：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

   可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

7. **抽奖、验证码**：set类型可以很方便的随机取。

8. **共同好友、好友推荐**：set类型的交并差运算。

9. **排行榜**：zset的排序功能。